def solution(storey):
    answer = 0
    while storey:  # storey가 0보다 클 때 작동
        last_num = storey % 10  # 일의 자리 숫자
        if last_num < 5:  # 5보다 작다면
            answer += last_num  # 내려가자
        elif last_num > 5:  # 5보다 크다면
            answer += 10 - last_num  # 올라가자
            storey += 10  # storey의 십의 자리 숫자를 키우는 효과
        else:  # 5라면
            if (storey // 10) % 10 < 5:  # 십의 자리 숫자가 5보다 작다면
                answer += last_num  # 내려가자
            else:  # 십의 자리 숫자가 5보다 같거나 크다면
                answer += 10 - last_num  # 올라가자
                storey += 10  # storey의 십의 자리 숫자를 키우는 효과
        storey //= 10  # 자릿수 줄이기
    return answer


# dp로 접근 -> 점화식이 떠오르는가? 아니오. 오히려 i + 10, i + 100, i + 1000... 100,000,000 자리 내에서 계속 비교할 것이 늘어남.-> 시간초과 가능
# => 1. 100,000,000라는 숫자에서 이상함을 느낌. 2. dp는 점화식을 바탕으로 진행되는 것이지 저런 비교는 의미 없음.
# 수학적으로 접근:
# 1. 10^c로 폭이 정해졌다는 점에서, 어떤 자리수를 가지든 위 아래 이동의 경향이 깨지지 않음. -> 강력한 수학적 단서
# 2. 11: 2번 다 14: 5번 다 15: 6번(겹침) 16: 5번 업 / 81: 2번 85: 7 업 업 / 90: 2번 업 92: 9번 다 업 89: 11번 업 업
# 55: 10번 업 업 다, 다 다 45: 10번 다 다
# 수학적으로 풀기 위해서는 2번과 같이 머리 속으로는 쉽게 계산되는 것도 체계를 딱 잡아야 됨.
# 일의자리, 다음자리 보는 스킬 유용함. 알아둘 것.
# tip: 1의 자리만 보기 -> % 10을 사용하자
# tip: 다음 자릿수 보기 -> //=10을 해서 수 자체를 줄여버리자

# 사고의 흐름:
# dp 풀었던 유형과 비슷하다 -> dp -> 틀이 안 맞음 -> DP 아니면 BFS로 풀었던 유형도 있다 -> BFS 엄두가 안 난다 -> 원초적인 접근을 해보자. -> 숫자로 접근 BUT 5가 애매함.
# 교훈:
# 1. 수를 다루는 문제는 수 자체로 우선 해석하는 것이 중요하다. 반드시 그 시간을 가지고 출발하자.
# 2. 숫자를 문자로 바꿔 해석하는 것은 오류가 생길 가능성이 크다.
# 3. DP, BFS 등 유형으로 접근할 때 일반화된 틀을 벗어나는 경우가 생길 시 이걸 해도 되는지 다시 검토하자.


# 교훈
# 모든 경우의 수를 탐색해야 한다면? dfs를 생각해보자! (은혜 풀이)
